// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package grid

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type GridPayloadT struct {
	PlanId string `json:"planId"`
	ViewId string `json:"viewId"`
	WindowHash string `json:"windowHash"`
	AtomRevision int64 `json:"atomRevision"`
	Cells []float64 `json:"cells"`
	RowOffsets []int32 `json:"rowOffsets"`
	StringData []byte `json:"stringData"`
	StringOffsets []uint32 `json:"stringOffsets"`
}

func (t *GridPayloadT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	planIdOffset := flatbuffers.UOffsetT(0)
	if t.PlanId != "" {
		planIdOffset = builder.CreateString(t.PlanId)
	}
	viewIdOffset := flatbuffers.UOffsetT(0)
	if t.ViewId != "" {
		viewIdOffset = builder.CreateString(t.ViewId)
	}
	windowHashOffset := flatbuffers.UOffsetT(0)
	if t.WindowHash != "" {
		windowHashOffset = builder.CreateString(t.WindowHash)
	}
	cellsOffset := flatbuffers.UOffsetT(0)
	if t.Cells != nil {
		cellsLength := len(t.Cells)
		GridPayloadStartCellsVector(builder, cellsLength)
		for j := cellsLength - 1; j >= 0; j-- {
			builder.PrependFloat64(t.Cells[j])
		}
		cellsOffset = builder.EndVector(cellsLength)
	}
	rowOffsetsOffset := flatbuffers.UOffsetT(0)
	if t.RowOffsets != nil {
		rowOffsetsLength := len(t.RowOffsets)
		GridPayloadStartRowOffsetsVector(builder, rowOffsetsLength)
		for j := rowOffsetsLength - 1; j >= 0; j-- {
			builder.PrependInt32(t.RowOffsets[j])
		}
		rowOffsetsOffset = builder.EndVector(rowOffsetsLength)
	}
	stringDataOffset := flatbuffers.UOffsetT(0)
	if t.StringData != nil {
		stringDataOffset = builder.CreateByteString(t.StringData)
	}
	stringOffsetsOffset := flatbuffers.UOffsetT(0)
	if t.StringOffsets != nil {
		stringOffsetsLength := len(t.StringOffsets)
		GridPayloadStartStringOffsetsVector(builder, stringOffsetsLength)
		for j := stringOffsetsLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.StringOffsets[j])
		}
		stringOffsetsOffset = builder.EndVector(stringOffsetsLength)
	}
	GridPayloadStart(builder)
	GridPayloadAddPlanId(builder, planIdOffset)
	GridPayloadAddViewId(builder, viewIdOffset)
	GridPayloadAddWindowHash(builder, windowHashOffset)
	GridPayloadAddAtomRevision(builder, t.AtomRevision)
	GridPayloadAddCells(builder, cellsOffset)
	GridPayloadAddRowOffsets(builder, rowOffsetsOffset)
	GridPayloadAddStringData(builder, stringDataOffset)
	GridPayloadAddStringOffsets(builder, stringOffsetsOffset)
	return GridPayloadEnd(builder)
}

func (rcv *GridPayload) UnPackTo(t *GridPayloadT) {
	t.PlanId = string(rcv.PlanId())
	t.ViewId = string(rcv.ViewId())
	t.WindowHash = string(rcv.WindowHash())
	t.AtomRevision = rcv.AtomRevision()
	cellsLength := rcv.CellsLength()
	t.Cells = make([]float64, cellsLength)
	for j := 0; j < cellsLength; j++ {
		t.Cells[j] = rcv.Cells(j)
	}
	rowOffsetsLength := rcv.RowOffsetsLength()
	t.RowOffsets = make([]int32, rowOffsetsLength)
	for j := 0; j < rowOffsetsLength; j++ {
		t.RowOffsets[j] = rcv.RowOffsets(j)
	}
	t.StringData = rcv.StringDataBytes()
	stringOffsetsLength := rcv.StringOffsetsLength()
	t.StringOffsets = make([]uint32, stringOffsetsLength)
	for j := 0; j < stringOffsetsLength; j++ {
		t.StringOffsets[j] = rcv.StringOffsets(j)
	}
}

func (rcv *GridPayload) UnPack() *GridPayloadT {
	if rcv == nil {
		return nil
	}
	t := &GridPayloadT{}
	rcv.UnPackTo(t)
	return t
}

type GridPayload struct {
	_tab flatbuffers.Table
}

func GetRootAsGridPayload(buf []byte, offset flatbuffers.UOffsetT) *GridPayload {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GridPayload{}
	x.Init(buf, n+offset)
	return x
}

func FinishGridPayloadBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsGridPayload(buf []byte, offset flatbuffers.UOffsetT) *GridPayload {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &GridPayload{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedGridPayloadBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *GridPayload) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GridPayload) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GridPayload) PlanId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GridPayload) ViewId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GridPayload) WindowHash() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GridPayload) AtomRevision() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *GridPayload) MutateAtomRevision(n int64) bool {
	return rcv._tab.MutateInt64Slot(10, n)
}

func (rcv *GridPayload) Cells(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *GridPayload) CellsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GridPayload) MutateCells(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *GridPayload) RowOffsets(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *GridPayload) RowOffsetsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GridPayload) MutateRowOffsets(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *GridPayload) StringData(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *GridPayload) StringDataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GridPayload) StringDataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GridPayload) MutateStringData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *GridPayload) StringOffsets(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *GridPayload) StringOffsetsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *GridPayload) MutateStringOffsets(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func GridPayloadStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func GridPayloadAddPlanId(builder *flatbuffers.Builder, planId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(planId), 0)
}
func GridPayloadAddViewId(builder *flatbuffers.Builder, viewId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(viewId), 0)
}
func GridPayloadAddWindowHash(builder *flatbuffers.Builder, windowHash flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(windowHash), 0)
}
func GridPayloadAddAtomRevision(builder *flatbuffers.Builder, atomRevision int64) {
	builder.PrependInt64Slot(3, atomRevision, 0)
}
func GridPayloadAddCells(builder *flatbuffers.Builder, cells flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(cells), 0)
}
func GridPayloadStartCellsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func GridPayloadAddRowOffsets(builder *flatbuffers.Builder, rowOffsets flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(rowOffsets), 0)
}
func GridPayloadStartRowOffsetsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GridPayloadAddStringData(builder *flatbuffers.Builder, stringData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(stringData), 0)
}
func GridPayloadStartStringDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func GridPayloadAddStringOffsets(builder *flatbuffers.Builder, stringOffsets flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(stringOffsets), 0)
}
func GridPayloadStartStringOffsetsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GridPayloadEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
